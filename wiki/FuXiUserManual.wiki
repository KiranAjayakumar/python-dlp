#summary End User Manual for FuXi

= Introduction =

!FuXi (pronounced foo-shee) is a forward-chaining production system for Notation 3 Description Logic Programming.  FuXi was originally meant as a Python swiss army knife for all things semantic web related.  It works as a companion to RDFLib, a Python library for working with RDF.

= The Primary Modules =

An overview of the top-level modules in FuXi serves as an introduction to the general features of FuXi.  The FuXi libraries are divided as follows:

  * !FuXi.Horn 
  * !FuXi.Syntax
  * !FuXi.DLP  
  * !FuXi.Rete

== FuXi.Horn ==  

The Horn module was originally meant as a reference implementation of the W3C's Rule Interchange Format Basic Logic Dialect ( work in progress ) but eventually evolved into a Pythonic API for managing an abstract Logic Programming syntax.  This module is heavily used by both the DLP and Rete modules for (respectively) creating the rulesets converted from OWL RDF expressions and creating a Horn ruleset from a parsed Notation 3 graph.

The Horn module includes Python classes for each of the major components of the RIF BLD abstract syntax ([http://www.w3.org/TR/rif-bld/#EBNF_Grammar_for_the_Presentation_Syntax_of_RIF-BLD EBNF Grammar for the Presentation Syntax of RIF-BLD]):

  * !FuXi.Horn.HornRules.Ruleset
  * !FuXi.Horn.HornRules.Rule
  * !FuXi.Horn.HornRules.Clause
  * !FuXi.Horn.PositiveConditions.Condition
  * !FuXi.Horn.PositiveConditions.And
  * !FuXi.Horn.PositiveConditions.Or
  * !FuXi.Horn.PositiveConditions.Uniterm
  * ... etc ..
  
Horn rulesets can be built from the ground up by instantiating the objects piecemeal:

    Example: {?C rdfs:subClassOf ?SC. ?M a ?C} => {?M a ?SC}.

{{{
>>> clause = Clause(And([Uniterm(RDFS.subClassOf,[Variable('C'),Variable('SC')]),
...                      Uniterm(RDF.type,[Variable('M'),Variable('C')])]),
...                 Uniterm(RDF.type,[Variable('M'),Variable('SC')]))
>>> Rule(clause,[Variable('M'),Variable('SC'),Variable('C')])
Forall ?M ?SC ?C ( ?SC(?M) :- And( rdfs:subClassOf(?C ?SC) ?C(?M) ) )

>>> And([Uniterm(RDF.type,[RDFS.comment,RDF.Property]),
...      Uniterm(RDF.type,[OWL.Class,RDFS.Class])])
And( rdf:Property(rdfs:comment) rdfs:Class(owl:Class) )

>>> Exists(formula=Or([Uniterm(RDF.type,[RDFS.comment,RDF.Property]),
...                    Uniterm(RDF.type,[OWL.Class,RDFS.Class])]),
...        declare=[Variable('X'),Variable('Y')])
Exists ?X ?Y ( Or( rdf:Property(rdfs:comment) rdfs:Class(owl:Class) ) )

>>> And([Uniterm(RDF.type,[RDFS.comment,RDF.Property]),
...      Uniterm(RDF.type,[OWL.Class,RDFS.Class])]).n3()
u'rdfs:comment a rdf:Property .\\n owl:Class a rdfs:Class'
}}}

RIF BLD objects can also be constructed by parsing a Notation 3 document like so:

{{{
>>> from FuXi.Rete.RuleStore import N3RuleStore
>>> from FuXi.Horn.HornRules import Ruleset
>>> from rdflib.Graph import Graph
>>> from rdflib.syntax.NamespaceManager import NamespaceManager
}}}

First, we instantiate an !N3RuleStore which will be the recipient of the parsed Notation 3 assertions.  Then we instantiate an rdflib !NamespaceManager
passing on a Graph that makes use of the instantiated rulestore ( so that any namespace prefix definitions are picked up ).  Then an rdflib Graph is instanciated
using the rule store instance and namespace manager and the rdfs-rules.n3 Notation 3 document is parsed from the web:

{{{
>>> ruleStore = N3RuleStore()
>>> nsMgr = NamespaceManager(Graph(ruleStore))
>>> ruleGraph = Graph(ruleStore,namespace_manager=nsMgr)
>>> ruleGraph.parse('http://www.agfa.com/w3c/euler/rdfs-rules.n3',format='n3')
<Graph identifier=... (<class 'rdflib.Graph.Graph'>)>
>>> ruleStore._finalize()
}}}

Finally, a !Ruleset object is instantiated, passing the rule store and the namespace mappings.  The !RuleSet object is iterated over and each
of the rules parsed from the Notation 3 document are printed (which serializes each rule using the RIF BLD syntax)

{{{
>>> for rule in Ruleset(n3StoreSrc=ruleStore,nsMapping=ruleStore.nsMgr): print rule
... 
Forall ?Q ?P ?S ?O ( ?Q(?O ?S) :- And( owl:inverseOf(?P ?Q) ?P(?S ?O) ) )
Forall ?P ?S ?O ( ?P(?O ?S) :- And( owl:SymmetricProperty(?P) ?P(?S ?O) ) )
Forall ?P ?S ?O ?X ( ?P(?S ?O) :- And( owl:TransitiveProperty(?P) ?P(?X ?O) ?P(?S ?X) ) )
Forall ?Y ?P ?R ?X ( ?P(?X ?Y) :- And( owl:onProperty(?R ?P) owl:hasValue(?R ?Y) ?R(?X) ) )
... snip ...
Forall ?P ?S ?R ?O ( ?R(?S ?O) :- And( rdfs:subPropertyOf(?P ?R) ?P(?S ?O) ) )
Forall ?C ( rdfs:subClassOf(?C rdfs:Resource) :- rdfs:Class(?C) )
Forall ?A ?S ?B ( ?B(?S) :- And( rdfs:subClassOf(?A ?B) ?A(?S) ) )
Forall ?A ?C ?B ( rdfs:subClassOf(?A ?C) :- And( rdfs:subClassOf(?B ?C) rdfs:subClassOf(?A ?B) ) )
}}}

=== Serialization ===

From the example(s) above, instantiated RIF BLD objects can be serialized in one of two ways: as human-readable RIF syntax or as Notation 3.  The former serialization is built in by overriding the __repr__ class method; a standard mechanism used in order to ".. compute the ``official'' string representation of an object.".  The latter serialization can be achieved by invoking the _n3_ method on any RIF BLD Python object.

The Horn module simplifies the process of serializing appropriate QNames (or [http://www.w3.org/TR/curie/ curies]) for the URIs associated with Uniterms.  Uniterms can be thought of as the RIF equivalent of RDF statements or Logic Programming _atoms_.  In order to associate a namespace mapping dictionary (a Python dictionary of prefixes to rdflib.URIRef instances of the corresponding fully qualified namespace URI), a Uniterm constructor can be invoked and passed such a dictionary via the _newNss_ keyword argument
  
== !FuXi.Syntax ==  

The !FuXi.Syntax module incorporates the InfixOwl library (see the linked Wiki for more information). 

== !FuXi.DLP ==  

This module is a Description Horn Logic implementation as defined by Grosof, B. et.al. ("Description Logic Programs: Combining Logic Programs with 
Description Logic" [1]) in section 4.4.  As such, it implements recursive mapping functions "T", "Th" and "Tb" which result in "custom" (dynamic) rulesets, RIF Basic 
Logic Dialect: Horn rulesets [2], [3].  

For the non logic-inclined, this essentially allows OWL ontologies (or a subset of OWL ontologies) to be automatically converted to a set of rules that exactly capture the semantics of the OWL document.  This mechanism is fundamental to the larger framework that FuXi is a part of (python-dlp).  The premise is three-fold.  

First (and most importantly), the ruleset(s) generated from an OWL ontology will be much more tailored to the specific constraints of the ontology than a general-purpose ruleset would.  As such, the inference mechanism will be several orders of magnitude more efficient.

Secondly, tools that are used for authoring OWL ontologies are significantly more mature than those used for authoring Notation 3 rulesets (or any other comparable semantic web rule language).  In addition, ...

== !FuXi.Rete ==    

 
 
 