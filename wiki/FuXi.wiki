#labels Phase-Implementation,Phase-Requirements,Featured,Phase-Deploy,Phase-QA,Phase-Design
FuXi (pronounced foo-shee) is a forward-chaining production system for Notation 3 Description Logic Programming.

_[http://python-dlp.googlecode.com/svn/trunk/fuxi/ /trunk/fuxi/]_

[http://usefulinc.com/doap/ DOAP] file: _[http://python-dlp.googlecode.com/svn/trunk/fuxi/FuXi.rdf /trunk/fuxi/FuXi.rdf]_

requires: [http://rdflib.net/ RDFLib] [http://rdflib.net/2.4.0/ 2.4.0] - available: [http://packages.qa.debian.org/r/rdflib.html debian]

= Introduction =

FuXi (pronounced foo-shee) is a forward-chaining production system for Notation 3 Description Logic Programming.  It is implemented as a companion to RDFLib  â€“ which it requires for its various RDF processing.  


= Details =

  * FuXi is now [http://python-dlp.googlecode.com/svn/trunk/fuxi/ part] of the python-dlp SVN source tree

=== Background of RETE and RETE/UL Algorithms ===

It relies on Charles Forgy's Rete algorithm [4] for the many pattern/many object match problem.  It also implements algorithms outlined in the PhD thesis (1995) of Robert Doorenbos:

    Production Matching for Large Learning Systems.

Robert's thesis describes a modification of the original Rete algorithm that (amongst other things) limits the fact syntax (referred to as Working Memory Elements) to 3-item tuples (which corresponds quite nicely with the RDF abstract syntax).  The thesis also describes methods for using hash tables to improve efficiency of alpha nodes and beta nodes.  

An introductory description from the above:

    Rete (usually pronounced either "REET" or "REE-tee," from the Latin word for "network") deals with a production memory (PM) and a working memory (WM). Each of these may change gradually over time. The working memory is a set of items which (in most systems) represent facts about the system's current situation - the state of the external world and/or the internal problem-solving state of the system itself. Each item in WM is called a working memory element,or a WME.

The production memory is a set of productions (i.e., rules). A production is specified as a set of conditions, collectively called the left-hand side (LHS), and a set of actions, collectively called the right-hand side (RHS).

=== Python Idioms (hashing efficiently) ===

    * compiles an RDFLib N3 rule graph into AlphaNode and BetaNode instances
    * takes a fact (or the removal of a fact, perhaps?) and propagates down, starting from it's alpha nodes
    * stores inferred triples in provided triple source (an RDFLib graph) or a temporary IOMemory Graph by default

Like RDFLib, FuXi is very idiomatic and uses Python hash / set / list mechanism to maximize the matching efficiency of the [http://python-dlp.googlecode.com/svn/trunk/fuxi/lib/Rete/Network.py network].  The extent of the efficiency has not been fully explored and there is much more that can be done to improve the already impressive performance.

=== Network ===

[http://python-dlp.googlecode.com/svn/trunk/fuxi/fuxi.png]

FuXi's Network intances can be exported to a [http://www.graphviz.org/ Graphviz] *DOT* file and rendered to any image format.  [http://www.generic-programming.org/~dgregor/bgl-python/ Boost Graph Library - Python Bindings] is used for this.  This provides a nice visual feedback to the discrimination network built to a ruleset.

=== Roadmap & Limitations ===

FuXi currently implements production capabilities for a limited subset of Notation 3.  In particular built-ins are not implemented as they have a significant impact on the efficiency of a RETE network (which was really only intended for pattern matching). Robert's thesis includes algorithms / heuristics for implementing support for:

  * Negation 
  * Non-equality tests (read: built-in support)
  * Live addition/removal of rules
  * Support for removal of triples / WMEs

=== Installation ===

Fuxi is now setuptools integrated and can be installed via:

{{{
wget http://peak.telecommunity.com/dist/ez_setup.py
python ez_setup.py
easy_install fuxi
Fuxi
}}}

=== Command-line Program ===

Command-line help:

{{{
USAGE: Fuxi [options] factFile1 factFile2 ...
Options:
  --closure                  If present, the inferred triples are serialized 
                             along with the original triples if asked for. Otherwise
                             (the default behavior), only the inferred triples
                             are serialized
                             
  --output=OUT               Determines whether to serialize the inferred triples
                             to STDOUT using the specified RDF syntax ('xml','pretty-xml',
                             'nt','turtle',or 'n3') or to print a summary of the conflict set 
                             (from the RETE network) if the value of this option is
                             'conflict'
  --help
  --input-format=<FORMAT>    Determines the format of the RDF document(s) which
                             serve as the initial facts for the RETE network.
                             One of 'n3','trix', 'nt', or 'rdfa'
                             
  --optimize                 Suggest inefficiencies in the ruleset and exit
                     
  --stdin                    Parse STDIN as an RDF graph to contribute to the
                             initial facts for the RETE network using the 
                             specified format
                             
  --ns=PREFIX=NSURI          Register a namespace binding (QName prefix to a 
                             base URI).  This can be used more than once
                             
  --graphviz-out=<FILE>      A filename to write a graphviz diagram of the RETE
                             network to
  
  --rules=FILE1,FILE2,..     The Notation 3 documents to use as rulesets for the
                             RETE network
                             
  ---ruleFacts               Determines whether or not to attempt to parse 
                             initial facts from the rule graph.  Default by default
}}}