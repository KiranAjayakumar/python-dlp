#labels Phase-Implementation,Phase-Requirements,Featured,Phase-Deploy,Phase-QA,Phase-Design
FuXi (pronounced foo-shee) is a forward-chaining production system for Notation 3 Description Logic Programming.

= Introduction =

FuXi (pronounced foo-shee) is a forward-chaining production system for Notation 3 Description Logic Programming.  It is implemented as a companion to RDFLib  â€“ which it requires for its various RDF processing.  


= Details =

  * FuXi is now [http://python-dlp.googlecode.com/svn/trunk/fuxi/ part] of the python-dlp SVN source tree

=== Background of RETE and RETE/UL Algorithms ===

It relies on Charles Forgy's Rete algorithm [4] for the many pattern/many object match problem.  It also implements algorithms outlined in the PhD thesis (1995) of Robert Doorenbos:

    Production Matching for Large Learning Systems.

Robert's thesis describes a modification of the original Rete algorithm that (amongst other things) limits the fact syntax (referred to as Working Memory Elements) to 3-item tuples (which corresponds quite nicely with the RDF abstract syntax).  The thesis also describes methods for using hash tables to improve efficiency of alpha nodes and beta nodes.  

An introductory description from the above:

    Rete (usually pronounced either "REET" or "REE-tee," from the Latin word for "network") deals with a production memory (PM) and a working memory (WM). Each of these may change gradually over time. The working memory is a set of items which (in most systems) represent facts about the system's current situation - the state of the external world and/or the internal problem-solving state of the system itself. Each item in WM is called a working memory element,or a WME.

The production memory is a set of productions (i.e., rules). A production is specified as a set of conditions, collectively called the left-hand side (LHS), and a set of actions, collectively called the right-hand side (RHS).

=== Roadmap & Limitations ===

FuXi currently implements production capabilities for a limited subset of Notation 3.  In particular built-ins are not implemented as they have a significant impact on the efficiency of a RETE network (which was really only intended for pattern matching). Robert's thesis includes algorithms / heuristics for implementing support for:

  * Negation 
  * Non-equality tests (read: built-in support)
  * Live addition/removal of rules
  * Support for removal of triples / WMEs

=== Command-line Program ===

Command-line help:

{{{
chimezie@laptop:~/workspace/python-dlp/fuxi$ python Fuxi.py 
Fuxi.py [--help] [--stdin] [--ruleFacts] [--output=<'conflict' or 'n3' or 'xml'>] [--input-format=<'n3' or 'xml'>] [--ns=prefix=namespaceUri] [--graphviz-out=<file.out>] --facts=<facts1.n3,facts2.n3,..> --rules=<rule1.n3,rule2.n3>
Output:
        The --output option determines whether to serialize the inferred triples to STDOUT or to print a summary of the
        conflict set (from the RETE network)
Rule Facts:
        The --ruleFacts switch determines whether or not to attempt to parse initial facts from the rule graph
RETE network diagram:
        The graphviz-out option is a filename to write a graphviz diagram of the RETE network to
Input format
        The --input-format option determines the format of the RDF document(s) specified by --facts
Namespace bindings:
        The --ns option adds a prefix to namespace binding and is used by both the generated RETE network diagram and the serialization (if specified by --out)
}}}


=== Example of GRDDL-based Reasoning ===

Uses GRDDL Working Group's GRDDL.py [http://homer.w3.org/~connolly/projects/grddl-client/ implementation]

{{{
chimezie@laptop:~/workspace/python-dlp/fuxi$ python GRDDL.py --zone=http http://metacognition.info/ontologies/pomr.html | python Fuxi.py --stdin --input-format=xml --rules=test/pD-rules.n3 
Time to build production rule (RDFLib): 0.097156047821 seconds
Time to calculate closure on working memory: 6095.22485733 m seconds

  ... snip closure output ...

}}}